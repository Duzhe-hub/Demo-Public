Node.js：是一个基于 chrome V8 解析引擎的 JavaScript 运行环境。

    Node.js 运行环境包含了 V8 引擎(负责解析和执行 JS)和内置API(提供功能)，使用 JavaScript 调用这些 API 然后交由 V8 引擎负责解析
        1. 浏览器是 JavaScript 的前端运行环境
        2. Node.js是 JavaScript 的后端运行环境
        3. Node.js的内置 API 中不包含 DOM、BOM 和 Ajax
            
    node -v             查看 node.js 版本
    node jsFile.js      使用 Node 执行 js 代码，需要位于 js 文件所以在目录

---------------------------------------------------------------------------------------------------------------------------------------------

    fs 文件系统模块：
        fs 模块：是 node.js 中用来操作文件的模块，该模块提供的一系列方法和属性，用来满足用户对文件的操作需求。
            fs.readFile(path[, options], callback) 方法，读取指定文件中的内容
                path            文件存放路径的字符串
                options         指定的读取文件的编码格式，默认为 utf8
                callback        文件读取后通过回调函数获取结果

            fs.writeFile(file, data[, options], callback) 方法，向指定文件中写入内容
                file            指定文件的存放路径字符串，表示文件存放路径
                data            表示需要写入的文件内容
                options         指定的写入内容的编码格式，默认为 utf8
                callback        方法执行完毕的回调函数
            ! fs.writeFile() 方法可以用来创建文件，但是无法创建路径(文件夹)
            ! 重复调用 fs.writeFile() 方法向同一文件写入内容时，新内容会覆盖旧内容，而不是拼接到旧内容后面

        路径动态拼接问题：当执行 js 模块操作文件时，若提供的文件路径是相对路径(.\ 或者 ..\)，就会容易出现路径动态拼接错误的问题。
        原因：代码运行时，会以执行 node 命令时的所在目录，动态拼接出被操作文件的完整路径。
            解决方案一：执行 js 模块操作文件时提供一个完整路径，而不是相对路径。但该方法移植性差、不利于维护。
            解决方案二：使用 __dirname(表示当前文件所在目录) 替换掉文件的前缀路径，然后使用字符串拼接目标文件。

---------------------------------------------------------------------------------------------------------------------------------------------

    path 路径模块：是 node.js 中用来处理的模块，该模块提供的一系列方法和属性，用来满足用户对路径的处理需求。
        path.join([...paths]) 方法，将多个路径片段拼接成一个完整的路径字符串
            paths <string>      路径片段序列
            返回值 <string>
            ! 如果拼接的字符在有 ../ 则会抵消上一个路径，因为 ../ 代表当前路径的上一级路径

        path.basename(path[, ext]) 方法，可以获取路径中的最后一部分，从路径字符串中将文件名解析出来
            path <string>       表示一个路径的字符串
            ext <string>        表示文件扩展名，如果输入了则会删除指定的文件扩展名，只输出文件名
            返回值 <string>     路径中的最后一部分
            
        path.extname(path) 方法，获取路径中的扩展名部分
            path <string>       表示一个路径的字符串
            返回值 <string>     返回得到的扩展名部分

---------------------------------------------------------------------------------------------------------------------------------------------

        http 模块：是 node.js 中用来创建 web 服务器的模块，该模块提供的 http.createServer() 方法能够让一台普通的电脑变成 web 服务器，向外提供资源数据
        。
---------------------------------------------------------------------------------------------------------------------------------------------

    模块化：自顶向下逐层将系统拆分成若干模块的过程。对于整个系统开说，模块是可组合、分解和更换的单元。

    编程领域的模块化：遵守固定规则，将一个大文件拆分成独立并相互依赖的小模块。
        模块化的好处：
            1. 提高了代码的复用性
            2. 提高了代码的可维护性
            3. 可以实现按需加载

        模块化规范：对代码进行模块化拆分与组合时，需要遵守的规则。好处是降低沟通成本，方便各模块之间的相互调用。

    Node.js 中的模块三大类：
        1. 内置模块，由官方提供的，在下载时就存在与 Node.js 中。
        2. 自定义模块，由用户创建的每个 js 文件，都是自定义模块。
        3. 第三方模块，由第三方开发，非官方自带也不是用户自定义的模块，使用前需要先下载。
    
    加载模块：require() 方法，可以加载需要的内置模块、自定义模块和第三方模块进行使用。
        ! 加载自定义模块时需要添加文件的路径，文件的后缀名可以省略。
        ! 当使用 require() 方法加载模块时会自动执行该模块中的方法。
    
    模块作用域：自定义模块中的成员变量以及方法，只能在该模块内部访问。这种模块级别的访问限制，就是模块作用域。
    (模块作用域的好处就是阻止全局变量的污染)
    
    向外共享模块作用域中的成员：
        1. module 对象：存在自定义模块中，该对象存储了和当前模块有关的信息。
        2. module.exports 对象：在自定义模块中，可以使用该对象将模块中的成员共享出去，供外界使用。默认是一个空对象。
            (当外界使用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象)
        3. exports 对象： module.exports 的简化对象，默认情况下所指向的对象与  module.exports 一致，最终共享结果永远以 module.exports 所指向对象为准。
            ! require() 导入模块时，导入的结果永远以 module.exports 指向的对象为准。
            ! 当 module.exports 与 exports 指向的对象相同时，exports 无法改变 module.exports 指向的对象。
            ! 当 module.exports 与 exports 指向的对象不同时，exports 指向的对象会添加到 module.exports 指向的对象中。
    
    Node.js 中的模块化规范：Node.js 遵循 CommonJS 模块化规范，规定了模块的特性和各模块之间如何相互依赖。

    CommonJS 规定：
        1. 每个模块内部，module 变量代表当前模块。
        2. module 变量是一个对象，它的 exports 属性(即 module.exports) 是对外的接口。
        3. 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。

---------------------------------------------------------------------------------------------------------------------------------------------

    Node.js 中的第三方模块又称为包。

    包的来源：由第三方个人或团队开发，是免费供人使用的。是基于内置模块封装出来的，提供了更高级、更方便的 API，极大提高了开发效率。
    包下载路径：
        搜索包的域名：      https://www.npmjs.com/
        下载包的服务器：    https://registry.npmjs.org
    
    包的语义化版本规范：包版本以 “点分十进制” 形式进行定义，共三位数字，例如：2.24.0，含义如下：
        第一位数字：大版本，当包的代码发生底层重构时版本号加一。
        第二位数字：功能版本，新增功能时版本号加一。
        第三位数字：Bug 修复版本，修复 Bug 后版本号加以。
        增长规则：前面的版本好修改，则后面的版本号归零。
    
    包的分类：
        1. 项目包：安装到项目的 node_modules 目录中的包
            开发依赖包：只在开发期间使用的包，记录在 devDependencies 节点
            核心依赖包：开发和上线期间都需要使用的包，记录在 dependencies 节点
        2. 全局包：安装时使用 -g 参数的包，安装到 C:\Users\Administrator\AppData\Roaming\npm\node_modules 路径中
            ! 只有工具性质的包才有安装全局的必要性，可以参照官方提供说明判断是否需要安装到全局中

    规范的包结构：
        1. 必须以单独的目录而存在
        2. 顶级目录下必须包含 package.json 包管理配置文件
        3. package.json 中必须包含 name、version、main 这三个属性，分别代表包名、版本号、报的入口。
        (https://yarnpkg.com/zh-Hans/docs/package-json)
    
    自定义包的初始化结构：
        1. 新建一个文件夹，作为包的根目录
        2. 根目录中新建三个文件
            (1) package.json    (包管理配置文件)
            (2) index.js        (包的入口文件)
            (3) README.md       (包的说明文档：没有特殊要求，只需要将包的功能、用法、注意事项描述清楚即可)
    
    包管理工具(Node Package Manager , 简称 npm)：用于从服务器中下载需要的包到本地，该工具是随 Node.js 的一起安装到计算机中，无需独立下载。
    使用 npm 安装包后的文件：
        1. node_modules 文件夹：用来存放已安装到项目中的包。使用 require() 导入第三方包时，从该目录中查找并加载包。
        2. package-lock.json 配置文件：用来记录 node_modules 目录中每个包的下载信息，例如：包名、版本号、下载地址等。
    
    上传项目时需要忽略 node_modules 文件夹。忽略后创建一个 package.json 配置文件，记录项目中用到的包。
        dependencies    节点：记录项目中安装的第三方包和版本号。
        devDependencies 节点：记录只在开发中使用，上线后不需要使用的包。
    
    使用 npm install 会自动安装最新版本的包，指定版本号需要在包名后加上 @版本号。重复安装时旧包会被新包覆盖。
    执行 npm install 命令时，包管理工具首先检查 package.json 中的 dependencies 节点，读取记录的所有依赖包和版本号，一次性安装到项目中。

        npm init -y                                                 在当前目录中，快速创建 package.json 文件
        npm install packageName                                     从源服务器中安装指定的包
        npm install                                                 一次性安装所有 package.json 的 dependencies 节点中记录的依赖包
        npm install packageName --save-dev                          安装指定包并记录到 devDependencies 
        npm uninstall packageName                                   卸载指定的第三方包

        npm -v                                                      查看 npm 包管理工具的版本号
        npm login                                                   登录 npm 账号
        npm publish                                                 发布包，需要位于包的根目录且登录服务器是 https://registry.npmjs.org
        npm unpublish packageName --force                           删除 npm 已发布的包，只能删除 72 小时以内发布的包，删除后 24 小时以内不能重复发布

        npm config get registry                                     查看当前的下包镜像源
        npm config set registry=http://registry.npm.taobao.org/     切换下包镜像源，淘宝镜像服务器

    i5ting_toc 工具包：将 md 文件装换为 html 文件
        npm install i5ting_toc                                      安装 i5ting_toc 工具包
        i5ting_toc -f md文件路径 -o                                 转换 md 文件为 html 文件并打开

---------------------------------------------------------------------------------------------------------------------------------------------

    模块的加载机制：
        1. 优先从缓存中加载：模块第一次加载后会被缓存，此后再调用多次的 require() 不会导致模块的代码被多次执行。
        2. 内置模块加载机制：加载的优先级最高。当有多个模块同名时，优先加载内置模块。
        3. 自定义模块加载机制：
            使用 require() 加载自定义模块时，需要添加路径符(./ ../)，否则会将自定义模块当成内置模块或第三方模块进行加载。
            使用 require() 加载自定义模块时，若忽略可文件扩展名，Node.js 会按顺序分别尝试加载以下文件：
                ① 按照确切的文件名加载
                ② 补全 .js 文件扩展名进行加载
                ③ 补全 .json 扩展名进行加载
                ④ 补全 .node 扩展名进行加载
        4. 第三方模块加载机制：require() 加载第三方模块是，node.js 会从当前模块的父目录开始，尝试从 node_modules 文件夹中加载第三方模块。若查找不到则返回上一级目录中进行加载，直到文件系统盘的根目录。
        5. 目录作为模块：将目录作为模块标识符，传递给 require() 加载时的三种加载方式：
            - 在被加载目录下查找 package.json 文件中的 main 属性，将属性值作为 require() 加载入口。
            - 目录中不存在 package.json 文件，或者 main 入口不存在，或文件无法解析，则尝试加载目录下的 index.js 文件夹。
            - 以上情况都失败，则会在终端返回一个错误消息，报道模块的缺失：Error:Cannot find module 'xxx'

---------------------------------------------------------------------------------------------------------------------------------------------